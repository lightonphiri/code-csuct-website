<HTML>
<HEAD>
<TITLE>/home/phiri/Projects/work/2015/uct-cs-csc1010h/tutorials/6/raw/mcnmon001/</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
/home/phiri/Projects/work/2015/uct-cs-csc1010h/tutorials/6/raw/mmlfhu003/<p><PRE>
&gt;&gt;&gt;&gt; file: fixed_mod.py
import string
def palindrome (s):
    s=str(s) # is the string entered by the user
    if len(s) == 1 or len(s)==0:# cheking the lenth of the string
        return True# BASE CASE
    if len(s)==2:
        if s[0]==s[-1]:
            return True # BASE CASE
        else:
            return False# BASE CASE
    elif s[0] in string.punctuation or s[0] in string.whitespace:# Removing anything which is not a letter situated in position 0 of a string
        return palindrome(s[1:])
    elif s[-1] in string.punctuation or s[-1] in string.whitespace:# Removing anything which is not a letter situated in position last of a string
        return palindrome(s[:-1])
    elif s[0].lower() == s[-1].lower():# comparing the last and the first letter of a string 
        return palindrome (s[1:-1])# chopping out the characters which are not the same
    else:
        return False&gt;&gt;&gt;&gt; file: match_mod.py
def match(pattern,word):
    if pattern[0]=="*" and pattern[-1]=="*": # if the word surrounded by the character "*"
        if len(pattern)==1 or len(pattern)==2:# it has to check if the length of the pattern is equal to one or three,because if the length is either of of this two it means tha there is no any character of cjharacters between "*"
            return True
        else:# if the pattern is surrounded by the character "*" but it has the length which is greater than 2 nit has to check if weatherv the charaters or the character which are between the "*" are the same as the remaining characters in word. to do that it has to cut cut off the "*" in both ends and compare the inner part 
            return match(pattern[1:-1],word)
    elif len(pattern)==1: # if the length of pattern is exactly equal to one it has to check if whether the remaining one character is in word or not. it doesnt have to return true because the pattern it can has the lenth of one and tha remaing one character being not in word if such thing happenned it has to return true else the it has to rteturn false 
        if pattern in word:
            return True 
        else:
            return False
    elif len(pattern)==0: # if the word chopped completly it means that the pattern entered by the user is exactly equal to word. im using this step as my strong base case
        return True
    elif pattern[0]=="*" and pattern[-1]!="*": # this condition is when the first end is equal to the character "*" and another end is not
        if word[-1]==pattern[-1]: # in this condition is checking if whether the last characters of the pattern and the word are equal it has to remove that characters and compare the remaining characters
            return match(pattern[:-1],word[:-1])
        else:# if the last characters of the word and pattern there  not the sanme it means that there is no need of going futher comparing the word it has to return false immidiatly
            return False
    elif pattern[0]!="*" and pattern[-1]=="*": # this conditionn is when the last chacter of the pattern is "*" and another one is not equal to "*' 
        if word[0]==pattern[0]: # it has to check if the first chactert of the word and the pattern are equal if thats true it hasd to chopp of that chacters and compare the remaing characters in pattern
            return match(pattern[1:],word[1:])
        else:# if the first characters there are not the same there will be no need of comparing. it has to return False
            return False
    elif pattern[0]!="*" and pattern[-1]!="*" and pattern[0]!="?" and pattern[-1]!="?":# this condition is for when both ends there not equal tom "*" or "?"
        if pattern[0]==word[0]:# this condition is checking if weather the first characters of word and pattern are equal, if thats true it has to get inside the body of the condition and chop off the characters which are the same
            return match(pattern[1:],word[1:])
        else:# if the first characters are not the same there will be no need of comparing the rest of rest of the characters it has to erturn false
            return False 
    elif pattern[0]=="?":# if the entered pattern it has the character in possition one which is equal to "?",it has to check if the last character are the same if thats true it has to chop off the first character and the last characters of pattern and word. is also chopping the first character because we know that where there is character "?" they can be any letter
        if pattern[-1]==word[-1]:
            return match(pattern[1:-1],word[1:-1])
        elif pattern[-1]=="?":# this condition is checking if also the last character is equal to "?" ,if that is true it to cut off the fist and the last character of the patter.
<A NAME="0"></A><FONT color = #FF0000><A HREF="match155-0.html#0" TARGET="0"><IMG SRC="../../bitmaps/tm_0_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

            return match(pattern[1:-1],word[1:-1])
    elif pattern[-1]=="?":
        if pattern[0]==word[0]:
            return match(pattern[1:-1],word[1:-1]) 
</FONT>def query(pattern, word):
    if len(pattern)!=len(word):# if the lengths of both pattern and the word are not equal the will be no need of comparing the rest of the word it has to return false indicating that the words are not the same
        return False
    elif pattern=="":# BASE CASE.Pattern is equal to an empty string it means that the word are equal because each time my program it will be running  towards an empty string
        return True
    elif pattern[0]==word[0]:# this condition is checking if whether the firt characters of pattern and word are equal if thats true it has to cut off that characters
        if pattern[-1]==word[-1]:
            return query(pattern[1:-1],word[1:-1])
        elif pattern[-1]!="?":#
            return False
        else:
            return True
    elif pattern[0]=="?" and pattern[-1]=="?":
        return True
    elif pattern[0]=="?":
        if pattern[-1]==word[-1]:
<A NAME="1"></A><FONT color = #00FF00><A HREF="match155-0.html#1" TARGET="0"><IMG SRC="../../bitmaps/tm_1_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

            return query(pattern[:-1],word[:-1])
        else:
            return False
    elif pattern=="?":
        return True
    elif pattern[0]!=word[0] and pattern[0]!="?":
</FONT>        return False
def equals(word_one, word_two):
    word_one=word_one.lower()#here im trying to cast all the characters from word_one to lowercase
    word_two=word_two.lower()#casting word_two to lowercase
    if word_one=="" and word_two=="":# base case if both word one and word two are equal it mean thatthose two words were the same it has to return true
        return True
    elif word_one!="" and word_two=="":# BASE CASE if one is equal to a string and the other is not it has to return False indicating that two words are not the same
        return False
    elif word_one=="" and word_two!="":
        return False
    elif word_one[0]==word_two[0]:#if characters in position one in boths words are equal it has to return that word back to the function without the similler characters
        return equals(word_one[1:],word_two[1:])
    else:# BASE CASE this conditon is checking if wheather both conditions are not True it means that woprd one and word two are not the same
<A NAME="2"></A><FONT color = #0000FF><A HREF="match155-0.html#2" TARGET="0"><IMG SRC="../../bitmaps/tm_2_3.gif" ALT="other" BORDER="0" ALIGN=left></A>

        return False

           &gt;&gt;&gt;&gt; file: mongoose_mod.py
def population(n):
    # n is the number of months
    if n&lt;=2:# We know that the population between 1 and 2 months it was still 2 (there were still 2 mangoose 
        return 2
    else:
        return population(n-1)+population(n-2) # multiple recursion is taking place at this position

    
        &gt;&gt;&gt;&gt; file: sum_mod.py
#c=0
def sum_to_n(n):
</FONT>    c=0 # BASE CASE COUNTER
    if c==n+1:
        return 0
    else:
        c+=1
        return n+sum_to_n(n-1) #WHERE RECURSION IS TAKING PLACE
    
    
    </PRE>
</PRE>
</BODY>
</HTML>
